[comment encoding = UTF-8 /]
[**
 * The documentation of the module generate_rtsc.
 */]
[module LocalMiddleware('http://www.muml.org/pim/connector/1.0.0', 'http://www.muml.org/pim/behavior/1.0.0',
				'http://www.muml.org/core/1.0.0',
				'http://www.muml.org/pim/actionlanguage/1.0.0',
				'http://www.muml.org/pim/msgtype/1.0.0',
				'http://www.muml.org/pim/types/1.0.0',
				'http://www.muml.org/modelinstance/1.0.0',
				'http://www.muml.org/pim/component/1.0.0',
				'http://www.muml.org/pim/instance/1.0.0',
				'http://www.muml.org/pim/realtimestatechart/1.0.0')]


[import org::muml::codegen::c::queries::stringQueries]
[import org::muml::codegen::c::queries::modelQueries]
[import org::muml::codegen::c::queries::middlewareQueries]
[import org::muml::codegen::c::actionlanguage::expression]
[import org::muml::codegen::c::files::RealtimeStatechart]


[**
 * Generates the class for the given component.
 * 
 * @param component The component for which the class will be generated.
 * @param statechart The behaviour of the component, if one exist otherwise NULL.
 */]
[template public generateLocalMiddleware(CIs : OrderedSet(ComponentInstance), path : String, useSubDir: Boolean)]
	[generateMiddlewareCoreFiles(CIs, path, useSubDir)/]
[/template]

[**
 * In this template all sub-templates are called, which are use to generate the middleware files.
 * Please use additional module-files to organize all templates.
 * 
 * This template will be called by the main-template of the code generation.
 * @param rsri the home ECU for the middleware
 * @param path the current file path for generating files
 */]
[template public generateMiddlewareCoreFiles(CIs : OrderedSet(ComponentInstance), path : String, useSubDir : Boolean)]
[generateMiddlewareCoreHeader(CIs, path, useSubDir)/]
[generateMiddlewareCoreClass(CIs, path, useSubDir)/]

[generateGlobalIdentifierFiles(CIs, path, useSubDir)/]

[comment generate dummy files, which needed for compatibility/]
[file(path+getFileName4MWInternalLogic(true, useSubDir),false,'UTF-8')]
//this file is empty, since it's content is not needed for PIM->Code generation
[/file]
[file(path+getFileName4MWNetworkInterfaces(true, useSubDir),false,'UTF-8')]
//this file is empty, since it's content is not needed for PIM->Code generation
[/file]
[file(path+getFileName4MWInternalLogic(false, useSubDir),false,'UTF-8')]
//this file is empty, since it's content is not needed for PIM->Code generation
[/file]
[file(path+getFileName4MWNetworkInterfaces(false, useSubDir),false,'UTF-8')]
//this file is empty, since it's content is not needed for PIM->Code generation
[/file]

[/template]


[**
 * Generates the includes for a given ECU
 * @param rsri the given ECU (home-ECU for the middleware)
*/]
[template private MWincludes(CIs : OrderedSet(ComponentInstance), useSubDir : Boolean)]
#include "[if (useSubDir)]../lib/[/if]MiddlewareTypes.h"
#include "GlobalIdentifier.h"
#include "[if (useSubDir)]../lib/[/if]NetworkMessageBuffer.h"
#include "[if (useSubDir)]../lib/[/if]NetworkInterface.h"
#include "[if (useSubDir)]../lib/[/if]port.h"
#include "[if (useSubDir)]../messages/[/if]messages_types.h" 

[/template]


[**
 * Generates the header file for the middleware core.
 * @param rsri the given ECU (home-ECU for the middleware)
 * @param path the current file-path for generating files
*/]
[template private generateMiddlewareCoreHeader(CIs : OrderedSet(ComponentInstance), path : String, useSubDir: Boolean)]
[file(path+getFileName4MWCore(true, useSubDir),false,'UTF-8')]
/**
 * @file 
 * @author generated by Fraunhofer IEM
 * @brief Specification of the Core Functionality of the Middleware
 * @details This files contains the main Functions of the Middleware and the global variable Middleware mw
 * 
 */

#ifndef MIDDLEWARECORE_H_
#define MIDDLEWARECORE_H_
#ifdef __cplusplus
  extern "C" {
#endif
[MWincludes(CIs, useSubDir)/]


/**
 * 
 * @brief Description of the Middleware
 * @details It contains the Components, which are allocated on a ECU
 */
typedef struct Middleware {

//Create components
[for (compInst : ComponentInstance | CIs) ? (compInst.oclIsKindOf(AtomicComponentInstance))]
[if ((compInst.componentType.componentKind = ComponentKind::SOFTWARE_COMPONENT) or (compInst.componentType.componentKind = ComponentKind::HYBRID_COMPONENT))]
	struct	[compInst.getClassName()/]* [compInst.getVariableName()/]; /**< The ComponentInstance: [compInst.getName()/] of Type: [compInst.getClassName()/]*/
[/if]
[/for]

//intern NetworkInterface	
NetworkInterface* intern;  /**< Pointer to the internal NetworkInterface */

//Create NetworkMessageBuffer
NetworkMessageBuffer* outgoing; /**< Pointer to the NetworkMessageBuffer, which stores the outgoing #MiddlewareMessage%s */
NetworkMessageBuffer* incoming; /**< Pointer to the NetworkMessageBuffer, which stores the incoming #MiddlewareMessage%s */

ECUID idOfECU; /**< The ECUID of the ECU on which the Middleware is executed - dummy for Systems with only one ECU*/

}Middleware;


/**
 * @brief Global Variable Middleware
 * @details Since, the Middleware is used in different places, we use this global variable to access the Middleware
 * @\warning Only one Middleware is allowed per ECU
 */
extern Middleware *mw;

/**
 * @brief Creates the Middleware
 * @details Allocates Memory for the struct Middleware, creates its #NetworkInterface%s, and initializes the Middleware
 * @return A Pointer to the new created Middleware
 * @note This Function is called by the system initialization (once)
 */
Middleware* Middleware_create(void);

/**
 * @brief Initialize the Middleware
 * @details This Function initializes the Middleware, by setting Middleware::idOfECU, and creating the NetworkMessageBuffer Middleware::incoming, and Middleware::outgoing
 * @return True, if the Middleware is successfully initialized, otherwise False
  */
bool_t Middelware_init(void);

/**
 * @brief Destroys the Middleware
 * @details Frees the Memory for the struct Middleware
 * @return True, if the Middleware is successfully destroyed, otherwise False
 */
bool_t Middleware_destroy(void);

/**
 * @brief Takes an arbitary Message, and stores it the NetworkMessatgeBuffer::outgoing
 * @details Takes an arbitary Message, and iff it is a ProtoBuf Message transforms it into an byte-Array, finally the Messages is enqued in Middleware::outgoing
 * 
 * @param targetPort The PortID of the target Port to which this Message shall be send
 * @param id The MessageID of the Message which shall be send
 * @param msg The Message to send
 * @return True
 */
bool_t MW_sendMessage(PortID targetPort, MessageID id, void *msg);

/**
 * @brief Delivers received Messages to the correct #MessageBuffer%s
 * @details Dequeues alls Messages out of Middleware::incoming and delivers them to the correct #MessageBuffer%s
 * @note This Function will be called periodically
 * @return True
 */
bool_t MW_deliverReceivedMessages(void);

/**
 * @brief Receives Messages for every known NetworkInterface
 * @details Calls the receive Function for each NetworkInterface, which is contained in the struct Middleware
 *          and enques them in Middleware::incoming
 * @return False
 */
bool_t MW_NIreceiveMessages(void);

/**
 * @brief All outgoing Messages are sent via a corresponding NetworkInterface
 * @details Takes all Messages from Middleware::outgoing, and selects for each the corresponding NetworkInterace, and sends the Message via send Function of the NetworkInterface
 * @return False
 */
bool_t MW_NIsendMessages(void);

/**
 * @brief Get the Port with the given PortID
 * @details This function returns a Pointer to a Port for a given PortID
 *          and which is contained in the struct Middleware
 * 
 * @param portID the PortID for which the corresponding Port shall be returned
 * @return A Pointer to the Port with the given PortID, if none could be found NULL
 * @note returns NULL if no Port could be found
 */
Port* MW_getPortforIdentifier(PortID portID);

/**
 * @brief Return the  PortID of a receiving port for a given sender PortID
 * @details This function returns the PortID of every Port
 * 
 * @param portID the PortID of the sender Port
 * @return the PortID of the corresponding receiver Port, if no one could be found 0
 * @note returns 0 if no receiver Port could be found
 */
PortID MW_getTargetPortIDforIdentifier(PortID portID);

#ifdef __cplusplus
  }
#endif
#endif /* MIDDLEWARECORE_H_ */

[/file]
[/template]

[**
 * Generates the implementation file for the middleware core.
 * @param rsri the given ECU (home-ECU for the middleware)
 * @param path the current file-path for generating files
*/]
[template private generateMiddlewareCoreClass(CIs : OrderedSet(ComponentInstance), path : String, useSubDir : Boolean)]
[file(path+getFileName4MWCore(false, useSubDir),false,'UTF-8')]
#include "MiddlewareCore.h"
//import all needed ComponentHeaders
[for (component : Component | CIs.componentType) ? (component.oclIsKindOf(AtomicComponent))]
[if ((component.componentKind = ComponentKind::SOFTWARE_COMPONENT) or (component.componentKind = ComponentKind::HYBRID_COMPONENT))]
#include "[if (useSubDir)]../[/if][component.getFileName(true, useSubDir)/]"
[/if]
[/for]

/*
 * create a new middleware instance
 * called by the system initialization (once)
 */
Middleware* Middleware_create(void){
	mw = (Middleware*) malloc(sizeof(Middleware));
	/*
	 * call create-function for every NI of the ECU
	 */
	mw->intern = NetworkInterface_create("intern");

	if(Middelware_init() == true){
		return mw;
	}
	else{
		return NULL;
	}

}

/*
 * initialize the middleware instance
 * called by the system initialization (once)
 */
bool_t Middelware_init(void){
		
	if (mw != NULL){
        mw->idOfECU = 1;
        mw->incoming = NetworkMessageBuffer_create(15, true);
        mw->outgoing = NetworkMessageBuffer_create(15, true);
		return true;
	}else
		return false;
}

/*
 * destroys the middleware instance
 * called by the system initialization (once)
 */
bool_t Middleware_destroy(void){
	if (mw != NULL){
		//destroy all components
[comment iterate over all component instances/]
[for (compInst : ComponentInstance | CIs) ? (compInst.oclIsKindOf(AtomicComponentInstance))]
[if ((compInst.componentType.componentKind = ComponentKind::SOFTWARE_COMPONENT) or (compInst.componentType.componentKind = ComponentKind::HYBRID_COMPONENT))]
	[componentType.getDestroyMethodName()/](mw->[compInst.getVariableName()/]);
[/if]
[/for]

//destroy all network interfaces
	NetworkInterface_destroy(mw->intern);
[comment iterate over all knwon network interfaces/]


//destroy all NetworkMessageBuffer
  	NetworkMessageBuffer_destroy(mw->incoming);
    NetworkMessageBuffer_destroy(mw->outgoing);
// destroy the middleware itself
		free(mw);
		return true;
	}else
		return false;
}

/*
 * sends a message.
 */
bool_t MW_sendMessage(PortID targetPort, MessageID id, void *msg){
	MiddlewareMessage* nwMsg = (MiddlewareMessage*) malloc(sizeof(MiddlewareMessage));
	nwMsg->_msgID = id;
	nwMsg->_targetPort = targetPort;
	
	//choose right function to create the bytearray (which is actually a chararray).
	switch(id){
[comment do for all message-types, used on this ECU/]
[for(msgtype: MessageType | getAllUsedMessages(CIs)) ? (msgtype.parameters->size()>0)]
	case [getIdentifierVariableName(msgtype)/]:
			nwMsg->_mumlMsg_len = [msgtype.getMarshallingMethodName()/](([getVariableName(msgtype)/]*)msg, nwMsg->_mumlMsg, 0);
			break;
[/for]
		default:
			nwMsg->_mumlMsg_len = 0;
			break;
	}
	Port *p = MW_getPortforIdentifier(targetPort);
	if (p != NULL){
		Port_addMessage(p, nwMsg);
		
		
		return true;
	}
	else
		return false;


}


/*
 * calls the receive-message of the middleware and delivers all messages to the correct buffers
 * will be called periodically
 */
bool_t MW_deliverReceivedMessages(void){
//not needed for local middleware
return true;	
}


/*
 * receives messages for every known NetworkInterface
 */
bool_t MW_NIreceiveMessages(void){
  //not needed for local middleware  
	
    return true;
}

/*
 * as long we have messages in the outgoing-buffer,
 * we try to send them via the "best" network interface
 */
bool_t MW_NIsendMessages(void){
	//not needed for local middleware
return true;
}


Port* MW_getPortforIdentifier(PortID portID){
    switch (portID) {
[for (port: DiscretePortInstance |getAllDiscretePortInstances(CIs)) ? ( port.connectorInstances->size()<2 and port.componentInstance.oclIsKindOf(AtomicComponentInstance))]
case [port.getIdentifierVariableName()/]:
	return mw->[port.componentInstance.getVariableName()/]->[port.portType.getVariableName()/];
	break;
[/for]
        default:
            return NULL;
    }
    
}


/*
* Return the  PortID of a receiving port for a given sender PortID
*
*/
PortID MW_getTargetPortIDforIdentifier(PortID portID){ 
switch (portID) {
      [for (port: DiscretePortInstance | getAllDiscretePortInstances(CIs))?(port.oclIsKindOf(DiscretePortInstance))]
		case [getIdentifierVariableName(port.oclAsType(DiscretePortInstance))/]:
		[comment  get the DiscretePortInstance to which this PortInstance "port" is connected; is always a 1-1 Relation, thus, the first one is choosen/]
		return [getIdentifierVariableName(port.getTargetPortInstance())/];
		break;
	[/for]
        default:
            return -1;
    }
}
[/file]
[/template]

[template public generateGlobalIdentifierFiles(CIs : OrderedSet(ComponentInstance), path : String, useSubDir: Boolean)]
[file(path+getFileName4GI(useSubDir), false, 'UTF-8')]
/**
 * @file 
 * @author generated by Fraunhofer IEM
 * @brief The GlobalIdentifiers
 * @details In this file the GlobalIdentifiers are specified via preprocessor macros
 * 			 These GlobalIdentifiers are equal for all ECUs
 */
		[comment generate IDs for messages/]
		//Define MessageType IDs
		[for (msg : MessageType | getAllUsedMessages(CIs))]
			#define [msg.getIdentifierVariableName()/] [i/] /**< Global Identifier: For the Message-Type: [msg.name/] */
		[/for]

		[comment generate IDs for ports/]
		//Define Port IDs
		[for (port : DiscretePortInstance | getAllDiscretePortInstances(CIs))]
			#define [port.getIdentifierVariableName()/] [i/] /**< Global Identifier: For the Discrete-Port-Instance: [port.name/] */
		[/for]
[/file]
[/template]

[template public generateOSFileDummy(path: String, OS:String, useSubDir: Boolean)]
[file(path+getFileName4OS(useSubDir),false,'UTF-8')]
#define [OS/]
[/file]
[/template]
