[comment encoding = UTF-8 /]
[**
 * The documentation of the module generate_rtsc.
 */]
[module componentHeader('http://www.muml.org/pim/connector/1.0.0', 'http://www.muml.org/pim/behavior/1.0.0',
				'http://www.muml.org/core/1.0.0',
				'http://www.muml.org/pim/actionlanguage/1.0.0',
				'http://www.muml.org/pim/msgtype/1.0.0',
				'http://www.muml.org/pim/types/1.0.0',
				'http://www.muml.org/modelinstance/1.0.0',
				'http://www.muml.org/pim/component/1.0.0',
				'http://www.muml.org/pim/instance/1.0.0',
				'http://www.muml.org/pim/realtimestatechart/1.0.0')]
[import org::muml::codegen::c::queries::stringQueries]
[import org::muml::codegen::c::queries::modelQueries]
[import org::muml::codegen::c::actionlanguage::expression]
[import org::muml::codegen::c::files::RealtimeStatechart]


[**
 * Generates the class for the given component.
 * 
 * @param component The component for which the class will be generated.
 * @param statechart The behaviour of the component, if one exist otherwise null.
 */]
[template public generate_ComponentHeader(component : Component, path : String, useSubDir : Boolean)]
	[file (path+getFileName(component, true, useSubDir), false, 'UTF-8')]
/**
 * @file 
 * @author generated by Fraunhofer IEM 
 * @brief Specification of Component of Type: [component.getName()/]
 * @details This files contains a description of the [component.getName()/] in form of the [getClassName(component)/]
 * 			and all methods which can be executed on an Instance of this Component
 */
		#ifndef [getHeaderDefine(component)/]
		#define [getHeaderDefine(component)/]

#ifdef __cplusplus
  extern "C" {
#endif
			[includes(component, useSubDir)/]
	
			[variables(component)/]
		
			[initialize(component)/]
	
			[constructor(component)/]
	
			[destroy(component)/]
		
			
			[processStep(component)/]
		
			[getterAndSetter(component)/]
		
			[queueMethods(component)/]


#ifdef __cplusplus
  }
#endif
		#endif /* [getHeaderDefine(component)/] */
	[/file]
[/template]

[**
 * @param component
 * @param statechart
*/]
[template public includes(component : Component, useSubDir: Boolean)]
	// Library
	#include "[if (useSubDir)]../types/[/if]standardTypes.h"
	#include "[if (useSubDir)]../types/[/if]customTypes.h"
	[if (component.eAllContents(DiscretePort)->size()>0)]
		#include "[if (useSubDir)]../lib/[/if]port.h"
		#include "[if (useSubDir)]../messages/[/if]Messages.h"

	[/if]
	[if (component.eAllContents(HybridPort)->size() > 0)]
		#include "[if (useSubDir)]../[/if][getFileName4ContinuousImpl(true, useSubDir)/]"	
	[/if]

	[if (component.oclIsKindOf(AtomicComponent))]
	[let rtsc : RealtimeStatechart = component.oclAsType(AtomicComponent).behavior]
		//#include "[if (useSubDir)]../[/if][getFileName(rtsc, true,useSubDir)/]"	
	[/let]
	[/if]
[/template]

[**
 * Generates the member variables.
 * 
 * @param component
 * @param statechart
*/]
[template private variables (component : Component) post (trim())]
[if component.oclIsKindOf(AtomicComponent)]
/**
 * @brief Forward Declaration of the struct [getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/] which describes the behavior of [getClassName(component)/]
 * 
 */
 typedef struct [getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/] [getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/];
[/if]
/**
 * @brief Forward Declaration of the struct [getClassName(component)/]
 */
	typedef struct [getClassName(component)/] [getClassName(component)/];

/**
*  
* @brief Description for a ComponentInstance of Type: [component.getName()/]
* @details This struct describes a specific Component Instances which is typed over the Component: [component.getName()/]
*/
struct [getClassName(component)/] {

		[comment if structured component, list all embedded components/]
		[if component.oclIsKindOf(StructuredComponent)]
		[for (cpart : ComponentPart | component.oclAsType(StructuredComponent).embeddedComponentParts)]
			[getClassName(cpart)/]* [getVariableName(cpart)/];
		[/for]
		[/if]

		[comment if atomic, list the RTSC of the component/]
		[if (component.oclIsKindOf(AtomicComponent) and (not(componentKind=ComponentKind::CONTINUOUS_COMPONENT)))]
			[getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/]* stateChart;	/**< The [getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/] of the Component [component.getName()/] */
		[/if]
	
		[comment list all ports of the component/]
		[comment list all ports of the component/]
		[for (port : Port | component.ports) ? (port.oclIsTypeOf(DiscretePort))]
				Port* [getVariableName(port)/]; /**< A Pointer to the Component's Port: [port.getName()/] */
		[/for]

		[if component.oclIsKindOf(AtomicComponent)]
		[for (port : Port | component.ports)]
			[if (port.oclIsTypeOf(HybridPort))]
				[if port.oclAsType(HybridPort).outPort]
					void (*setterOf_[port.oclAsType(HybridPort).getName()/])([port.oclAsType(HybridPort).dataType.getTypeName()/]);/**< A Pointer to the setter function of the hybrid port: [port.getName()/] */
				[else]
					[port.oclAsType(HybridPort).dataType.getTypeName()/] (*getterOf_[port.oclAsType(HybridPort).getName()/])(void);/**< A Pointer to the getter function of the hybrid port: [port.getName()/] */
				[/if]

			[/if]
		[/for]
			
		[/if]
		
		

		[comment add list pointer/]
		[component.getClassName()/] * next;/**< A Pointer to the next component part, if this component ist part of a multipart in the CIC */
		
	};

[/template]

[**
 * @param component
 * @param statechart
*/]
[template private initialize (component : Component) post (trim())]
/**
* @brief This Methodes intializes the Component: [component.getName()/]
* @details All struct members of the struct [getClassName(component)/] are initialized
* 
* @param component The [getClassName(component)/] to be initialized
*/	
	void [getInitializeMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generates the constructor.
 * 
 * @param component
 * @param statechart
*/]
[template public constructor (component : Component) post (trim())]
/**
* @brief Creates a Instance of the Component: [component.getName()/]
* @details Allocates Memory for the struct [getClassName(component)/]
* @return A Pointer to the new created [getClassName(component)/]
*/
	[getClassName(component)/]* [getCreateMethodName(component)/]();
[/template]

[**
 * 
*/]
[template private destroy(component : Component)]
/**
 * @brief Destroys a Component: [component.getName()/]
 * @details Frees the Memory for the struct [getClassName(component)/]
 * 
* @param component The specific [getClassName(component)/] to be destroyed
 */
	void [getDestroyMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generates the isTerminated method.
 * 
 * @param component
 * @param statechart
*/]
[template private isTerminated (component : Component) post (trim())]
/**
* @brief Checks if the execution of the Component: [component.getName()/]  is terminated
* @details To Check if the execution is terminated the Method is terminated of the stateChart is called
*		
* @param component The specific [getClassName(component)/] which shall be checked
* @return True, if the Component is terminated, otherwise false
*/
	bool_t [getTerminateMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generated the processStep method.
 * 
 * @param component
 * @param statechart
*/]
[template private processStep (component : Component) post (trim())]
/**
* @brief Executes the next Step of the behavior an Instance of the Component: [component.getName()/]
* @details The behavior of the Component:  [component.getName()/] is executed.
*			
* @param component The [getClassName(component)/] whose behavior shall be checked
*/
	void [getProcessMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generates the getter methods for the statechart and all ports.
 * 
 * @param component
 * @param statechart
*/]
[template private getterAndSetter (component : Component) post (trim())]
	[if (component.oclIsTypeOf(AtomicComponent))]
	[let rtsc : RealtimeStatechart = component.oclAsType(AtomicComponent).behavior]
		[getClassName(rtsc)/]* [getGetterName(component)/]([getClassName(component)/]* component);
	[/let]
	[/if]

	[for (port : Port | component.ports)]
	[if (port.oclIsKindOf(DiscretePort))]
/**
		 * @brief Get the Port: [port.getName()/] of an Instance of the Component: [component.getName()/]
		 * @details The Pointer [getClassName(component)/]::[getVariableName(port)/] is returned
		 * 
		 * @param component The specific Instance [getClassName(component)/]  of the Component: [component.getName()/] whose Port shall be returned
		 * @return A Pointer to the Port [port.getName()/] of the struct [getClassName(component)/]
		 */
		[getClassName(port)/]* [getGetterName(port)/]([getClassName(component)/]* component);
	[/if]
	[/for]
[/template]

[**
 * 
 * @param component
*/]
[template private queueMethods(component : Component) post (trim())]
[if (component.oclIsKindOf(StructuredComponent))]
[for (compPart : ComponentPart | component.oclAsType(StructuredComponent).embeddedComponentParts->asSet())]
//Queue methods for component parts of type '[getName(compPart)/]'
void [getAddMethodName(component,compPart)/]([getClassName(component)/]* component, [getClassName(compPart)/]* multiPart);		
void [getRemoveMethodName(component,compPart)/]([getClassName(compPart)/]* component, [getClassName(compPart)/]* multiPart);
[/for]
[/if]
[/template]

