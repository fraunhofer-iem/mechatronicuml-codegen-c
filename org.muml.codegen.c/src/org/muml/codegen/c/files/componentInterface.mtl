[comment encoding = UTF-8 /]
[**
 * The documentation of the module generate_rtsc.
 */]
[module componentInterface('http://www.muml.org/pim/connector/1.0.0', 'http://www.muml.org/pim/behavior/1.0.0',
				'http://www.muml.org/core/1.0.0',
				'http://www.muml.org/pim/actionlanguage/1.0.0',
				'http://www.muml.org/pim/msgtype/1.0.0',
				'http://www.muml.org/pim/types/1.0.0',
				'http://www.muml.org/modelinstance/1.0.0',
				'http://www.muml.org/pim/component/1.0.0',
				'http://www.muml.org/pim/instance/1.0.0',
				'http://www.muml.org/pim/realtimestatechart/1.0.0',
				'http://www.muml.org/psm/1.0.0')]
[import org::muml::codegen::c::queries::stringQueries]
[import org::muml::codegen::c::queries::modelQueries]
[import org::muml::codegen::c::actionlanguage::expression]
[import org::muml::codegen::c::actionlanguage::operation_queries]
[import org::muml::codegen::c::files::RealtimeStatechart]


[template public generate_ComponentInterface(component : Component, path : String, useSubDir : Boolean)]
	[file (path+getFileName(component, true, useSubDir), false, 'UTF-8')]
	/**
 * @file 
 * @author generated by Fraunhofer IEM
 * @brief Specification of Component of Type: [component.getName()/]
 * @details This files contains a description of the [component.getName()/] in form of the [getClassName(component)/]
 * 			and all methods which can be executed on an Instance of this Component
 */
		#ifndef [getHeaderDefine(component)/]
		#define [getHeaderDefine(component)/]

#ifdef __cplusplus
  extern "C" {
#endif
			[includes(component, useSubDir)/]
	
			[variables(component)/]
		
			[initialize(component)/]
	
			[constructor(component)/]
	
			[destroy(component)/]
		
			
			[processStep(component)/]
		
			[getterAndSetter(component)/]
		
			[queueMethods(component)/]

[if (component.componentKind=ComponentKind::SOFTWARE_COMPONENT or component.componentKind=ComponentKind::HYBRID_COMPONENT )]
		
	[let rtsc : RealtimeStatechart = component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart)]
/**
 * @file 
 * @author generated by Fraunhofer IEM
 * @brief Specification of Realtime-StateChart: [rtsc.getName()/]
 * @details This files contains the description of the Realtime-StateChart: [rtsc.getName()/] and its behavior which is executed
 */
	//ENUM
	[variables(component, rtsc)/]

//METHOD STUBS
	[constructor(component, rtsc)/]
	[initialize(rtsc)/]
	[destroy(rtsc)/]		
	[process(rtsc)/]

	[exit(rtsc)/]
			
	[isInState(rtsc)/]
	

[comment generate operation declarations for the RTSC/]
//RTSC internal operations
[let allOperation : Set(Operation) = rtsc.eAllContents(Operation)->asSet()]
[for (operation : Operation | allOperation)]


[operation.returnType.getTypeName()/] [operation.getName()/]([rtsc.getClassName()/]* stateChart[for (p: Parameter | operation.parameters)], [p.dataType.getTypeName()/] [p.getName()/][/for]);

[/for]
[/let]




	[/let]
[/if]





#ifdef __cplusplus
  }
#endif
		#endif /* [getHeaderDefine(component)/] */


	[/file]
[/template]



[**
 * @param component
 * @param statechart
*/]
[template public includes(component : Component, useSubDir: Boolean)]
	// Library
	#include "[if (useSubDir)]../types/[/if]standardTypes.h"
	#include "[if (useSubDir)]../types/[/if]customTypes.h"
	[if (component.eAllContents(DiscretePort)->size()>0)]
		#include "[if (useSubDir)]../lib/[/if]port.h"
		#include "[if (useSubDir)]../messages/[/if]Messages.h"

	[/if]
[if (component.componentKind=ComponentKind::SOFTWARE_COMPONENT or component.componentKind=ComponentKind::HYBRID_COMPONENT )]
	[if (component.eAllContents(HybridPort)->size() > 0)]
		#include "[if (useSubDir)]../[/if][getFileName4ContinuousImpl(true, useSubDir)/]"	
	[/if]
	[let rtsc : RealtimeStatechart = component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart)]
		[if ((rtsc.eAllContents(Operation)->asSet() - rtsc.eAllContents(APICall)->asSet())->size() > 0)]#include "../operations/operations.h"[/if]
		[if (rtsc.eAllContents(APICall)->size() > 0)]#include "../apiCallCode/implementations.h"[/if]
	[/let]	
[/if]
	

	#include "[if (useSubDir)]../lib/[/if]clock.h"
#include "[if (useSubDir)]../lib/[/if]Debug.h"
#include "[if (useSubDir)]../lib/[/if]MiddlewareTypes.h"
#include "[if (useSubDir)]../Middleware/[/if]MiddlewareCore.h"
	

[/template]

[**
 * Generates the member variables.
 * 
 * @param component
 * @param statechart
*/]
[template private variables (component : Component) post (trim())]
[if component.oclIsKindOf(AtomicComponent)]
/**
 * @brief Forward Declaration of the struct [getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/] which describes the behavior of [getClassName(component)/]
 * 
 */
 typedef struct [getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/] [getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/];
[/if]
/**
 * @brief Forward Declaration of the struct [getClassName(component)/]
 */
	typedef struct [getClassName(component)/] [getClassName(component)/];

/**
*  
* @brief Description for a ComponentInstance of Type: [component.getName()/]
* @details This struct describes a specific Component Instances which is typed over the Component: [component.getName()/]
*/
struct [getClassName(component)/] {

		[comment if structured component, list all embedded components/]
		[if component.oclIsKindOf(StructuredComponent)]
		[for (cpart : ComponentPart | component.oclAsType(StructuredComponent).embeddedComponentParts)]
			[getClassName(cpart)/]* [getVariableName(cpart)/];
		[/for]
		[/if]

		[comment if atomic, list the RTSC of the component/]
		[if (component.oclIsKindOf(AtomicComponent) and (not(componentKind=ComponentKind::CONTINUOUS_COMPONENT)))]
			[getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/]* stateChart;	/**< The [getClassName(component.oclAsType(AtomicComponent).behavior.oclAsType(RealtimeStatechart))/] of the Component [component.getName()/] */
		[/if]
	
		[comment list all ports of the component/]
		[comment list all ports of the component/]
		[for (port : Port | component.ports) ? (port.oclIsTypeOf(DiscretePort))]
				Port* [getVariableName(port)/]; /**< A Pointer to the Component's Port: [port.getName()/] */
		[/for]

		[if component.oclIsKindOf(AtomicComponent)]
		[for (port : Port | component.ports)]
			[if (port.oclIsTypeOf(HybridPort))]
				[if port.oclAsType(HybridPort).outPort]
					void (*setterOf_[port.oclAsType(HybridPort).getName()/])([port.oclAsType(HybridPort).dataType.getTypeName()/]);/**< A Pointer to the setter function of the hybrid port: [port.getName()/] */
				[else]
					[port.oclAsType(HybridPort).dataType.getTypeName()/] (*getterOf_[port.oclAsType(HybridPort).getName()/])(void);/**< A Pointer to the getter function of the hybrid port: [port.getName()/] */
				[/if]

			[/if]
		[/for]
			
		[/if]
		
		

		[comment add list pointer/]
		[component.getClassName()/] * next;/**< A Pointer to the next component part, if this component ist part of a multipart in the CIC */
		
	};

[/template]

[**
 * @param component
 * @param statechart
*/]
[template private initialize (component : Component) post (trim())]
/**
* @brief This Methodes intializes the Component: [component.getName()/]
* @details All struct members of the struct [getClassName(component)/] are initialized
* 
* @param component The [getClassName(component)/] to be initialized
*/	
	void [getInitializeMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generates the constructor.
 * 
 * @param component
 * @param statechart
*/]
[template public constructor (component : Component) post (trim())]
/**
* @brief Creates a Instance of the Component: [component.getName()/]
* @details Allocates Memory for the struct [getClassName(component)/]
* @return A Pointer to the new created [getClassName(component)/]
*/
	[getClassName(component)/]* [getCreateMethodName(component)/]();
[/template]

[**
 * 
*/]
[template private destroy(component : Component)]
/**
 * @brief Destroys a Component: [component.getName()/]
 * @details Frees the Memory for the struct [getClassName(component)/]
 * 
* @param component The specific [getClassName(component)/] to be destroyed
 */
	void [getDestroyMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generates the isTerminated method.
 * 
 * @param component
 * @param statechart
*/]
[template private isTerminated (component : Component) post (trim())]
/**
* @brief Checks if the execution of the Component: [component.getName()/]  is terminated
* @details To Check if the execution is terminated the Method is terminated of the stateChart is called
*		
* @param component The specific [getClassName(component)/] which shall be checked
* @return True, if the Component is terminated, otherwise false
*/
	bool_t [getTerminateMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generated the processStep method.
 * 
 * @param component
 * @param statechart
*/]
[template private processStep (component : Component) post (trim())]
/**
* @brief Executes the next Step of the behavior an Instance of the Component: [component.getName()/]
* @details The behavior of the Component:  [component.getName()/] is executed.
*			
* @param component The [getClassName(component)/] whose behavior shall be checked
*/
	void [getProcessMethodName(component)/]([getClassName(component)/]* component);
[/template]

[**
 * Generates the getter methods for the statechart and all ports.
 * 
 * @param component
 * @param statechart
*/]
[template private getterAndSetter (component : Component) post (trim())]
	[if (component.oclIsTypeOf(AtomicComponent))]
	[let rtsc : RealtimeStatechart = component.oclAsType(AtomicComponent).behavior]
		[getClassName(rtsc)/]* [getGetterName(component)/]([getClassName(component)/]* component);
	[/let]
	[/if]

	[for (port : Port | component.ports)]
	[if (port.oclIsKindOf(DiscretePort))]
/**
		 * @brief Get the Port: [port.getName()/] of an Instance of the Component: [component.getName()/]
		 * @details The Pointer [getClassName(component)/]::[getVariableName(port)/] is returned
		 * 
		 * @param component The specific Instance [getClassName(component)/]  of the Component: [component.getName()/] whose Port shall be returned
		 * @return A Pointer to the Port [port.getName()/] of the struct [getClassName(component)/]
		 */
		[getClassName(port)/]* [getGetterName(port)/]([getClassName(component)/]* component);
	[/if]
	[/for]
[/template]

[**
 * 
 * @param component
*/]
[template private queueMethods(component : Component) post (trim())]
[if (component.oclIsKindOf(StructuredComponent))]
[for (compPart : ComponentPart | component.oclAsType(StructuredComponent).embeddedComponentParts->asSet())]
//Queue methods for component parts of type '[getName(compPart)/]'
void [getAddMethodName(component,compPart)/]([getClassName(component)/]* component, [getClassName(compPart)/]* multiPart);		
void [getRemoveMethodName(component,compPart)/]([getClassName(compPart)/]* component, [getClassName(compPart)/]* multiPart);
[/for]
[/if]
[/template]


[**
 * Generates the enum for the statechart.
 * 
 * @param statechart
*/]
[template public variables (comp: Component, rtsc: RealtimeStatechart) post(trim())]
/** 
 * @brief This enum represents the States of the Realtime-StateChart: [rtsc.getName()/]
 */
	typedef enum {
		[rtsc.getQualifiedName().toUpperCase()/]_INACTIVE,
	[for (state : State | rtsc.states) separator (',')]
		[getStateNames(state)/]	
	[/for]
	}[getClassName(rtsc, true)/];


	/**
	 * 
	 * @brief Description of the Realtime-StateChart: [rtsc.getName()/]
	 * @details This struct represents the  Realtime-StateChart: [rtsc.getName()/] and its States
	 */
struct [getClassName(rtsc)/] {	
		[comment Member variable for the parent component. /]	
		[comp.getClassName()/] * parentComponent;/**< A pointer to the parent ComponentInstance of Type: [comp.getClassName()/] , which has this Realtime-StateChart as its behavior */			


					[getClassName(rtsc, true)/] [getVariableName(rtsc)/];/**< The current State of the Realtime-StateChart: [rtsc.getName()/] */
		[comment Member variables for the current state of each region. /]	

		[for (region : Region | rtsc.eAllContents(Region))]
			[getClassName(rtsc, true)/] [getVariableName(region.embeddedStatechart)/];/**< Represents the state of region: [region.getName()/] */
		[/for]

		bool_t [rtsc.getExecutionVerifierName()/];/**< Execution Verifier of RTSC: [rtsc.getName()/]. This variable is used to ensure that a RTSC is executed only once per execution cycle */
		[for (region : Region | rtsc.eAllContents(Region))]
			bool_t [region.embeddedStatechart.getExecutionVerifierName()/];/**< Execution Verifier of RTSC: [region.getName()/]. This variable is used to ensure that a RTSC is executed only once per execution cycle */
		[/for]
	
		[comment Member variables for the clocks of each region. /]
		[for (clock : Clock | rtsc.eAllContents(Clock))]
			Clock [getVariableName(clock)/];/**< The Clock: [clock.getName()/] */
		[/for]

		[comment member variables for do-event clocks. /]

		[for (state : State | rtsc.eAllContents(State)) ? (not state.doEvent.oclIsUndefined())]					

			Clock [getClockVariableName(state)/];/**< Clock for doEvent for state [state.getName()/] */
		[/for]
	
		[comment Member variables for the variables of each region. /]	

		[for (var : Variable | rtsc.eAllContents(Variable))] 
[if (var.dataType.oclIsKindOf(ArrayDataType))]
			[var.dataType.getTypeName()/] [getVariableName(var)/] [let arrayType: ArrayDataType = var.dataType.oclAsType(ArrayDataType)][if (arrayType.cardinality.value > 0 and not arrayType.cardinality.oclIsUndefined())]['['/][if (arrayType.cardinality.value > 32768)]32768[else][arrayType.cardinality.value/][/if][']'/][/if][/let]; /**< The Realtime-StateChart Variable: [var.getName()/] of Type: [var.dataType.name/]; */

[else]
			[var.dataType.getTypeName()/] [getVariableName(var)/]; /**< The Realtime-StateChart Variable: [var.getName()/] of Type: [var.dataType.name/]; */
[/if]		
[/for]

		[for (port : Port | comp.ports) ? (oclIsKindOf(HybridPort))]
			[let hPort : HybridPort = port.oclAsType(HybridPort)]
				[hPort.dataType.getTypeName()/] [hPort.getVariableName()/];
			[/let]		
		[/for]


		

		[if (rtsc.oclIsKindOf(ParameterizedRealtimeStatechart))]
			[let prtsc : ParameterizedRealtimeStatechart = rtsc.oclAsType(ParameterizedRealtimeStatechart)]
				[for (para : RealtimeStatechartParameter | prtsc.allParameters)]
					[if (para.oclIsKindOf(APICallParameter))]
					[let apiOp : Operation = para.oclAsType(Operation)]
						[apiOp.returnType.getTypeName()/] (*[apiOp.getMethodName()/])([for (p : Parameter | apiOp.parameters) separator (',')][p.dataType.getTypeName()/][/for]); /**< A Function Pointer to the API-Call: [apiOp.getName()/] */
					[/let]
					[/if]
				[/for]
			[/let]
		[/if]
	} ;
[/template]


[template private getStateNames (state : State) post(trim())]
[getName(state)/] /**< Represents the State: [state.getName()/] of the Realtime-StateChart: [state.parentStatechart.getName()/] */
[if not (state.simple)],
	[for (innerState : State | state.embeddedRegions.embeddedStatechart.states) separator (',')]
		[getStateNames(innerState)/]
	[/for]
[/if]
[/template]

[**
 * Generates header of the constructor of the statechart
 * 
 * @param statechart
*/]
[template public constructor (component: Component, rtsc : RealtimeStatechart) post(trim())]
/**
 * @brief Creates an Instance of the Realtime-StateChart: [rtsc.getName()/]
 * @details Allocates Memory for the struct [getClassName(rtsc)/]
 * 
 * @param parentComponent An Instance of the Component: [getClassName(component)/] which behavior is described via this Realtime-StateChart
 * @return A Pointer to the new created [getClassName(rtsc)/]
 */
	[getClassName(rtsc)/]* [getCreateMethodName(rtsc)/]([getClassName(component)/]* parentComponent);
[/template]

[template private initialize (rtsc : RealtimeStatechart) post(trim())]
/**
 * @brief Initializes an Instance of the Realtime-StateChart: [rtsc.getName()/]
 * @details All struct members of the struct [getClassName(rtsc)/] are initialized,
 *			and all Regions of the Realtime-StateChart are initialized, too.
 * 
 * @param rtsc The specific [getClassName(rtsc)/] to be initialized
 */
	void [getInitializeMethodName(rtsc)/]([getClassName(rtsc)/]* rtsc);
[for (region: Region | rtsc.eAllContents(Region))]
/**
 * @brief Initializes the Region: [region.getName()/] of the Realtime-StateChart: [rtsc.getName()/]
 * @details The Member [getClassName(rtsc)/]::[getVariableName(region.embeddedStatechart)/] is initialized
 * 
 * @param stateChart The specific [getClassName(rtsc)/] whose Region shall be initialized
 */

	void [getInitializeMethodName(region)/]([getSuperClassName(rtsc)/]* stateChart);
[/for]
[/template]

[template private destroy(rtsc : RealtimeStatechart) post(trim())]
/**
 * @brief Destroys the Realtime-StateChart: [rtsc.getName()/]
 * @details Frees the Memory for the struct [rtsc.getClassName()/]
 * 
 * @param rtsc The specific [rtsc.getClassName()/] to be destroyed
 */	
	void [getDestroyMethodName(rtsc)/]([getClassName(rtsc)/]* rtsc);
[/template]

[template private process (rtsc : RealtimeStatechart) post(trim())]
/**
 * @brief Executes the next Step of the Realtime-StateChart: [rtsc.getName()/]
 * 
 * @param rtsc The specific [rtsc.getClassName()/] to be executed
 */	
	void [getProcessMethodName(rtsc)/]([getClassName(rtsc)/]* rtsc);
[/template]

[template private exit (rtsc : RealtimeStatechart) post(trim())]
	[for (region : Region | rtsc.getAllRegions())]
/**
 * @brief Leaves the Region: [region.name/] of the Realtime-StateChart: [rtsc.getName()/]
 * @details This method is called, whenever a the Region: [region.name/] is left.
 * 			The correct State is set and all Exit-Events are executed.
 *
 * @param rtsc The specific [getClassName(rtsc)/] whose Region: [region.name/] shall be exit
 */
	void [getExitMethodName(region)/]([getClassName(rtsc)/]* rtsc);
	[/for]
[/template]

[template private isInState (rtsc : RealtimeStatechart) post(trim())]
/**
 * @brief Returns wether the Realtime-StateChart: [rtsc.getName()/] is in a specific State
 * 
 * @param rtsc The specific Realtime-StateChart: [rtsc.getClassName()/]
 * @param state One of the States of the Enum: [getClassName(rtsc, true)/]
 * 
 * @return True, If the Realtime-StateChart is in the specific State, otherwise False
 */	
	bool_t [getIsInStateMethodName(rtsc)/]([getClassName(rtsc)/]* rtsc, [getClassName(rtsc, true)/] state);
[/template]

